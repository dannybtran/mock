================
 The Mock Class
================

.. currentmodule:: mock


.. testsetup::

    from mock import Mock, sentinel

``Mock`` is a flexible mock object intended to replace the use of stubs and test doubles throughout your code. Mocks are callable and create attributes as new mocks when you access them [#]_. Accessing the same attribute will always return the same mock. Mocks record how you use them, allowing you to make assertions about what your code has done to them.

The :func:`mock.patch` decorators makes it easy to temporarily replace classes in a particular module with a Mock object.


.. class:: Mock(spec=None, magics=None, side_effect=None, return_value=None, items=None)

    Create a new ``Mock`` object. ``Mock`` takes several optional arguments that specify the behaviour of the Mock object:

    * ``spec``: This can be either a list of strings or an existing object (a class or instance) that acts as the specification for the mock object. If you pass in an object then a list of strings is formed by calling dir on the object (excluding unhandled magic attributes and methods). Accessing any attribute  not in this list will raise an ``AttributeError``. If the list contains any supported magic methods then the mock instance returned will have these methods. See `Mocking Magic Methods`_.

    * ``magics``: This can be a list of strings, or a single space separated string, listing the magic (protocol) methods the mock should have. For convenience the method names should not have the leading or trailing double underscores. Currently only container methods are supported. ``magics`` is ignored if the ``spec`` parameter is used.
    
      The following two ways of passing in a list of magic methods are equivalent:
      
      .. doctest::
      
        >>> mock = Mock(magics=['getitem', 'setitem'])
        >>> mock = Mock(magics='getitem setitem')

    * ``return_value``: The value returned when the mock is called. By default this is a new Mock (created on first access). See the :attr:`Mock.return_value` attribute.

    * ``side_effect``: A function to be called whenever the Mock is called. See the :attr:`Mock.side_effect` attribute. Useful for raising exceptions or dynamically changing return values.

    * ``items``: Used for mocking container objects. See `Mocking Magic Methods`_ and the :attr:`Mock._items` attribute.


Methods
=======

.. method:: Mock.reset()

    The reset method resets all the call attributes on a mock object:
    
    .. doctest::

        >>> mock = Mock()
        >>> mock('hello')
        <mock.Mock object at 0x...>
        >>> mock.called
        True
        >>> mock.reset()
        >>> mock.called
        False

    This can be useful where you want to make a series of assertions that reuse the same object. Note that ``reset`` *doesn't* clear the return value, ``side_effect`` or any child attributes. Attributes you have set using normal assignment are also left in place. Child mocks and the return value mock (if any) are reset as well.
    
    If you passed in an ``items`` argument when the mock was constructed, or set the :attr:`Mock._items` attribute, to one of the built-in container types (dict, tuple, set, list) then reset will replace the current value with a copy of the original.


.. method:: Mock.assert_called_with(*args, **kwargs)

    This method is a convenient way of asserting that calls are made in a particular way:

    .. doctest::
    
        >>> mock = Mock()
        >>> mock.method(1, 2, 3, test='wow')
        <mock.Mock object at 0x...>
        >>> mock.method.assert_called_with(1, 2, 3, test='wow')


Calling
=======
    
Mock objects are callable. The call will return the value set as the :attr:`Mock.return_value` attribute. The default return value is a new Mock object; it is created the first time the return value is accessed (either explicitly or by calling the Mock) - but it is stored and the same one returned each time.

Calls made to the object will be recorded in the attributes_.

If :attr:`Mock.side_effect` is set then it will be called after the call has been recorded but before any value is returned.


Attributes
==========

.. attribute:: Mock.called

    A boolean representing whether or not the mock object has been called:

    .. doctest::

        >>> mock = Mock(return_value=None)
        >>> mock.called
        False
        >>> mock()
        >>> mock.called
        True
    

.. attribute:: Mock.return_value

    Set this to configure the value returned by calling the mock:

    .. doctest::

        >>> mock = Mock()
        >>> mock.return_value = 'fish'
        >>> mock()
        'fish'
    
    The default return value is a mock object and you can configure it in the normal way:
    
    .. doctest::

        >>> mock = Mock()
        >>> mock.return_value.attribute = sentinel.Attribute
        >>> mock.return_value()
        <mock.Mock object at 0x...>
        >>> mock.return_value.assert_called_with()


.. attribute:: Mock.side_effect

    Sometimes when a mock is called you want to raise an exception (to test exception handling of an API) or return values from a sequence instead of a single value. These can be achieved with the ``side_effect`` attribute:
    
    .. doctest::

        >>> mock = Mock(return_value=None)
        >>> def side_effect():
        ...     raise Exception('Boom!')
        ... 
        >>> mock.side_effect = side_effect
        >>> mock()
        Traceback (most recent call last):
          ...
        Exception: Boom!
    
        >>> results = [1, 2, 3]
        >>> def side_effect():
        ...     mock.return_value = results.pop()
        ... 
        >>> mock.side_effect = side_effect
        >>> mock(), mock(), mock()
        (3, 2, 1)


.. attribute:: Mock.call_args

    This is either ``None`` (if the mock hasn't been called), or the arguments that the mock was last called with. This will be in the form of a tuple: the first member is any ordered arguments the mock was called with (or an empty tuple) and the second member is any keyword arguments (or an empty dictionary):
    
    .. doctest::

        >>> mock = Mock(return_value=None)
        >>> print mock.call_args
        None
        >>> mock()
        >>> mock.call_args
        ((), {})
        >>> 
        >>> mock(3, 4, 5, key='fish', next='w00t!')
        >>> mock.call_args
        ((3, 4, 5), {'key': 'fish', 'next': 'w00t!'})


.. attribute:: Mock.call_args_list

    This is a list of all the calls made to the mock object in sequence. Before any calls have been made it is an empty list:
    
    .. doctest::

        >>> mock = Mock()
        >>> mock()
        <mock.Mock object at 0x...>
        >>> mock(3, 4, 5, key='fish', next='w00t!')
        <mock.Mock object at 0x...>
        >>> mock.call_args_list
        [((), {}), ((3, 4, 5), {'key': 'fish', 'next': 'w00t!'})]


.. attribute:: Mock.method_calls

    As well as tracking calls to themselves, mocks also track calls to methods and attributes, and *their* methods and attributes:
    
    .. doctest::

        >>> mock = Mock()
        >>> mock.method()
        <mock.Mock object at 0x...>
        >>> mock.property.method.attribute()
        <mock.Mock object at 0x...>
        >>> mock.method_calls
        [('method', (), {}), ('property.method.attribute', (), {})]


.. note::

    If you pass in one of the built-in container types (list, dictionary, tuple or set) as the ``items`` keyword argument, then it is actually a shallow copy of this that is set as the ``_items`` attribute. This is so that :meth:`Mock.reset` can restore ``_items`` to a copy of the original.

.. attribute:: Mock._items

    Mock objects only have an ``_items`` attribute if they have any of the container magic methods (i.e. were created with an appropriate ``spec`` or ``magics`` argument). The default value for ``_items`` is None, but it will be replaced with any object passed in as the ``items`` keyword argument to the Mock constructor.
    
.. index:: Magic Methods

Mocking Magic Methods
=====================    
    
Mock is capable of mocking out objects that support some of the Python protocols methods; the magic methods that start and end with double underscores. The currently supported methods are all the methods used by the mapping and sequence protocols (for container objects):

* __getitem__
* __setitem__
* __delitem__
* __iter__
* __len__
* __contains__
* __nonzero__

It supports them by delegating these method calls to an underlying real container object (e.g. a dictionary or list) that you either pass in as the ``items`` keyword argument to the constructor or set as the ``_items`` attribute. You can control how the mock object responds to these methods by controlling what is in the underlying container. The method calls are recorded in the :attr:`Mock.method_calls` attribute, allowing you to make assertions about how it has been used.

Mock objects don't unconditionally implement all of these magic methods though; this could break duck typing in the code under test. Instead Mocks conditionally implement magic methods specified by the ``spec`` or ``magics`` keyword argument. Under the hood this is implemented using the :function:`MakeMock` function, which creates custom subclasses of mock that only 



(passing in a spec object that has any of these methods or including them in the list of valid attributes),  (a list of magic methods as strings without the leading and trailing double underscores - or as a single string with space separated).


MakeMock
========

.. function:: MakeMock(magics=[])

XXXX

.. [#] The only exceptions are magic methods and attributes (those that have leading and trailing double underscores). Mock doesn't create these but instead of raises an ``AttributeError``. This is because the interpreter will often implicitly request these methods, and gets *very* confused to get a new Mock object when it expects a magic method. This doesn't include the explicitly requested magic methods which are supported in a slightly different way.
    