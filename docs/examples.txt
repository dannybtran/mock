==========
 Examples
==========

For further examples, see the unit tests included in the full source distribution.

Mock Examples
=============

Mock Patching Methods
~~~~~~~~~~~~~~~~~~~~~

``Mock`` is callable. If it is called then it sets a ``called`` attribute to ``True``.

This example tests that calling ``method`` results in a call to ``something``:

.. raw:: html

    {+coloring}
    def test_method_calls_something(self):
        real = ProductionClass()
        real.something = Mock()
        
        real.method()
        
        self.assertTrue(real.something.called, "method didn't call something")
    {-coloring}
    
If you want to catch the arguments then there is other information exposed:

.. raw:: html

    {+coloring}
    def test_method_calls_something(self):
        real = ProductionClass()
        real.something = Mock()
        
        real.method()
        
        self.assertEquals(real.something.call_count, 1, "something called incorrect number of times")
        
        args = ()
        keywargs = {}
        self.assertEquals(real.something.call_args, (args, keywargs), "something called with incorrect arguments")
        self.assertEquals(real.something.call_args_list, [(args, keywargs)], 
                          "something called with incorrect arguments")
    {-coloring}

Checking ``call_args_list`` tests how many times the mock was called, and the arguments for each call, in a single assertion.


Mock for Method Calls on an Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. raw:: html

    {+coloring}
    def test_closer_closes_something(self):
        real = ProductionClass()
        mock = Mock()
        
        real.closer(mock)
        
        self.assertTrue(mock.close.called, "closer didn't close something")
    {-coloring}

We don't have to do any work to provide the 'close' method on our mock. Accessing close creates it. So, if 'close' hasn't already been called then accessing it in the test will create it - but ``called`` will be ``False``.

As ``close`` is a mock object is has all the attributes from the previous example.


Limiting Available Methods
~~~~~~~~~~~~~~~~~~~~~~~~~~

The disadvantage of the approach above is that *all* method access creates a new mock. This means that you can't tell if any methods were called that shouldn't have been. There are two ways round this. The first is by restricting the methods available on your mock.

.. raw:: html

    {+coloring}
    def test_closer_closes_something(self):
        real = ProductionClass()
        methods = ['close']
        mock = Mock(methods) # methods=methods is equivalent
        
        real.closer(mock)
        
        self.assertTrue(mock.close.called, "closer didn't close something")
    {-coloring}

If ``closer`` calls any methods on ``mock`` *other* than close, then an ``AttributeError`` will be raised.


Tracking all Method Calls
~~~~~~~~~~~~~~~~~~~~~~~~~

An alternative way to verify that only the expected methods have been accessed is to use the ``method_calls`` attribute of the mock. This records all calls to child attributes of the mock - and also to their children.

This is useful if you have a mock where you expect an attribute method to be called. You could access the attribute directly, but ``method_calls`` provides a convenient way of looking at all method calls:

.. raw:: html

    {+coloring}
    >>> mock = Mock()
    >>> mock.method()
    >>> mock.Property.method(10, x=53)
    >>> mock.method_calls
    [('method', (), {}), ('Property.method', (10,), {'x': 53})]
    >>> 
    {-coloring}

If you make an assertion about ``method_calls`` and any unexpected methods have been called, then the assertion will fail.


Setting Return Values and Setting Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Setting the return values on a mock object is trivially easy:

.. raw:: html

    {+coloring}
    >>> mock = Mock()
    >>> mock.return_value = 3
    >>> mock()
    3
    {-coloring}

Of course you can do the same for methods on the mock:

.. raw:: html

    {+coloring}
    >>> mock = Mock()
    >>> mock.method.return_value = 3
    >>> mock.method()
    3
    {-coloring}

If you need an attribute setting on your mock, just do it:

.. raw:: html

    {+coloring}
    >>> mock = Mock()
    >>> mock.x = 3
    >>> mock.x
    3
    {-coloring}

Sometimes you want to mock up a more complex situation, like for example ``mock.connection.cursor().execute("SELECT 1")``:


.. raw:: html

    {+coloring}
    >>> mock = Mock()
    >>> cursor = mock.connection.cursor.return_value
    >>>
    >>> mock.connection.cursor().execute("SELECT 1")
    >>> mock.method_calls
    [('connection.cursor', (), {})]
    >>> cursor.method_calls
    [('execute', ('SELECT 1',), {})]
    >>> 
    {-coloring}


Creating a Mock from an Existing Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One problem with over use of mocking is that it couples your tests to the implementation of your mocks rather than your real code. Suppose you have a class that implements ``some_method``. In a test for another class, you provide a mock of this object that *also* provides ``some_method``. If later you refactor the first class, so that it no longer has ``some_method`` - then your tests will continue to pass even though your code is now broken!

``Mock`` allows you to provide an object as a specification for the mock, using the ``spec`` keyword argument. Accessing methods / attributes on the mock that don't exist on your specification object will immediately raise an attribute error. If you change the implementation of your specification, then tests that use that class will start failing immediately without you having to instantiate the class in those tests.



.. raw:: html

    {+coloring}
    >>> mock = Mock(spec=SomeClass)
    >>>
    >>> mock.old_method()
    Traceback (most recent call last):
       ...
    AttributeError: object has no attribute 'old_method'
    {-coloring}


Patch Decorator Examples
------------------------

A common need in tests is to patch a class attribute or a module attribute, for example patching a builtin or patching a class in a module to test that it is instantiated. Modules and classes are effectively global, so patching on them has to be undone after the test or the patch will persist into other tests and cause hard to diagnose problems.

The patch_ and patch_object_ decorators provide a convenient way of doing this. 

``patch_object`` patches attributes on objects within the scope of a function they decorate:

.. raw:: html

    {+coloring}
    mock = Mock()
    
    @patch_object(SomeClass, 'class_method', mock) 
    def test():
        SomeClass.class_method()
    test()
    
    self.assertTrue(mock.called, "class_method not called")
    {-coloring}

The decorator is applied to a function (called ``test`` above). The patching only applies inside the body of the function. You have to call the function explicitly, this can be useful as the test function can take arguments and be used to implement several tests, it can also return values.

They can be stacked to perform multiple simultaneous patches:

.. raw:: html

    {+coloring}
    mock1 = Mock()
    mock2 = Mock()
    
    @patch_object(SomeClass, 'class_method', mock1) 
    @patch_object(SomeClass, 'static_method', mock2) 
    def test():
        SomeClass.class_method()
        SomeClass.static_method()
    test()
    
    self.assertTrue(mock1.called, "class_method not called")
    self.assertTrue(mock2.called, "static_method not called")
    {-coloring}

If you are patching a module (including ``__builtin__``) then use patch instead of patch_object:

.. raw:: html

    {+coloring}
    mock = Mock()
    mock.return_value = sentinel.Handle
    
    @patch('__builtin__.open', mock) 
    def test():
        return open('filename', 'r')
    
    handle = test()
    
    self.assertEquals(mock.call_args, (('filename', 'r'), {}), "open not called correctly")
    self.assertEquals(handle, sentinel.Handle, "incorrect file handle returned")
    {-coloring}
    
The module name can be 'dotted', in the form ``package.module`` if needed.


If you don't want to call the decorated test function yourself, you can add ``apply`` as a decorator on top:

.. raw:: html

    {+coloring}
    @apply
    @patch('Package.Module.attribute', sentinel.Attribute)
    def test():
        # do something
    {-coloring}


A nice pattern is to actually decorate test methods themselves:

.. raw:: html

    {+coloring}
    
    @patch_object(SomeClass, 'attribute', sentinel.Attribute)
    def testMethod(self):
        self.assertEquals(SomeClass.attribute, sentinel.Attribute, "SomeClass not patched")
    {-coloring}
    
    
If you omit the second argument to ``patch`` (or the third argument to ``patch_object``) then the attribute will be patched with a mock for you. The mock will be passed in as extra argument(s) to the function / method under test:

.. raw:: html

    {+coloring}
    
    @patch_object(SomeClass, 'staticmethod')
    def testMethod(self, mockMethod):
        SomeClass.staticmethod()
        self.assertTrue(mockMethod.called, "SomeClass not patched with a mock")
    {-coloring}


You can stack up multiple patch decorators using this pattern:

.. raw:: html

    {+coloring}
    
    @patch('Module.ClassName1')
    @patch('Module.ClassName2')
    def testMethod(self, mockClass1, mockClass2):
        ClassName1()
        ClassName2()
        self.assertEquals(mockClass1.called, "ClassName1 not patched")
        self.assertEquals(mockClass2.called, "ClassName2 not patched")
    {-coloring}


