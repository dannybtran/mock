==================
 Patch Decorators
==================


.. currentmodule:: mock

.. testsetup::

    import os, sys
    if not os.getcwd() in sys.path:
        sys.path.append(os.getcwd())
    from mock import Mock, sentinel, MakeMock


The patch decorators are used for patching objects only within the scope of the function they decorate. They automatically handle the unpatching for you, even if exceptions are raised.	   


patch
=====

.. function:: patch(target, new=None)

``patch`` decorates a function. Inside the body of the function, the ``target`` (specified in the form 'PackageName.ModuleName.ClassName') is patched with a ``new`` object. When the function exits the patch is undone.

The target is imported and the specified attribute patched with the new object - so it must be importable from the environment you are calling the decorator from.

If ``new`` is omitted, then a new ``Mock`` is created and passed in as an extra argument to the decorated function::

   @patch('Package.ModuleName.ClassName')
   def test_something(self, mockClass):
       # ...



patch_object
============

.. function:: patch_object(target, attribute, new=None)

    ``patch_object`` patches named members on objects - usually class or module objects.

You can either call it with three arguments or two arguments. The three argument form takes the object to be patched, the attribute name and the object to replace the attribute with.

When calling with the two argument form you omit the replacement object, and a mock is created for you and passed in as an extra argument to the decorated function::

    @patch_object(SomeClass, 'classmethod')
    def test_something(self, mockMethod):
        SomeClass.classmethod(3)
        
        mockMethod.assert_called_with(3) 


Nesting Patch Decorators
========================

XXXX

If you want to perform multiple patches then you can simply stack up the decorators on a function if you particularly feel the need.
